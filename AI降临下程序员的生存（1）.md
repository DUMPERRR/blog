AI降临，现在程序员的失业率非常高，国内国外都一样。

在这个情况下如何生存？

这是一道2018年下半年软考程序员级的题目：

<img width="445" height="754" alt="image" src="https://github.com/user-attachments/assets/cb7165b6-f45d-4a43-8cb8-ef38ec33e11e" />

问题问：分别输入 -1331，795，输出结果是什么？

我们来看一下：

程序先定义了三个整型变量a、tmp和b。a放置输入值，tmp放置临时结果，b放置输出结果。

scanf语句读取一个整数放进a。

tmp = a<0 ? -a : a，这一句是取a的绝对值。

while (tmp)循环是把tmp中的数字倒序，把结果放进b。其中，tmp % 10是取tmp的个位数。

balabala（此处作者删去1237字）

答案

输入：-1331

输出：Palindromic number.  （换行）a = -1331 b = 1331

输入：795

输出：a = 795 b = 597

**********

等等！潘老师你是来讲软考，然后鼓励大家考软考？

当然不是！

**********

我要说的是，刚才我们并没有把这段程序放到真正的编译器里面去编译、执行，而是根据C语言标准推导得到。

如果不信，你把它放到某一个C编译器去编译、执行，得到的结果就是这个。

<img width="624" height="542" alt="image" src="https://github.com/user-attachments/assets/59147e53-6e28-4a65-9e0e-691a08585735" />

但是，不同的编译器，针对不同的目标架构（x86-64、i386、ARM……）、操作系统（Windows、Linux、macOS……）、优化级别，得到的汇编是不一样的。

例如， Linux x86-64系统，使用GCC编译得到：

……

    pushq   %rbp

    movq    %rsp, %rbp

    subq    $16, %rsp         

    movl    $0, -12(%rbp)     

    leaq    -4(%rbp), %rax   

    movq    %rax, %rsi        

    leaq    .LC0(%rip), %rdi  

    movl    $0, %eax          

    call    scanf@PLT 

……

别的编译器、别的目标架构、别的操作系统，得到的内容会跟这个有区别。

但是没关系，结果是一样的。这个结果，并不受制于哪一个编译器，只受制于C语言标准。

这就是“C→汇编”这一步的“不这样不行”。

C代码这部分属于ABCD工作流的D-设计。同理，业务建模→需求→分析→设计，每一步我们都要学会清楚地区分“不这样不行”和“这样也行”。

我们只要死死地把控住“不这样不行”这个部分，任凭风吹雨打，AI如何发挥，得到的结果就是我们想要的。

就像船下了锚，可能还是会动，但会绕着锚在小范围内动，不会飘到某个我们无法控制的地方。

更多信息，参见：软件方法-全流程引领AI，http://umlchina.com/url/aiuml.html，或点击“阅读原文”。
