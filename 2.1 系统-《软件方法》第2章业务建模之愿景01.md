<img width="723" height="1050" alt="image" src="https://github.com/user-attachments/assets/a3e41a7a-a237-4a4f-8e46-eb04b45fb460" />
这城市已摊开她孤独的地图 我怎么能找到你等我的地方
《模范情书》；词：高晓松，曲：高晓松，唱：老狼；1996

以一个目标系统为研究对象，其愿景（Vision）的定义是：

从目标组织代表的视角看，目标系统最应该给目标组织带来的改进。

但要理解好这个定义并不容易，我们从头来理清一些概念。

2.1 系统
2.1.1 “系统”的历史
关于“系统”的研究，在计算机诞生之前就已经有了。

Arthur D. Hall在1962所著的“A Methodology for Systems Engineering”一书中提到，贝尔实验室从1940年代开始使用“Systems Engineering（系统工程）”一词，见图2-1。

<img width="850" height="413" alt="image" src="https://github.com/user-attachments/assets/08bdb5a8-15fe-4219-8d15-6611746ad84c" />

图2-1 贝尔实验室和系统工程，摘自A Methodology for Systems Engineering，Arthur D. Hall，1962

Arthur D. Hall的书还出现了object、attribute、relationship等词，如图2-2。这似乎在说面向对象软件开发，但实际上当时软件开发中的“面向对象”还没有诞生。仔细看文中的atom、star等词，可以知道此处说的“系统”并非我们现在当作缺省选项的信息系统，而是广义的“系统——对外能够提供某些服务，内部由若干部件组成的东西，从整个宇宙到一家企业、一个软件系统甚至一个细胞，都可以称为“系统”。

<img width="796" height="566" alt="image" src="https://github.com/user-attachments/assets/9e768255-c9f3-433a-83ae-81c640769f46" />

图2-2 Arthur D. Hall书中的“面向对象”

★“面向对象编程（object-oriented programming）”的说法是Alan Kay在1967年首先使用的（http://www.purl.org/stefan_ram/pub/doc_kay_oop_en）。Simula-67是第一门面向对象编程语言。

2.1.2 系统的分类
本书第1章在讲到UML和SysML在建模中的区别时，谈到了处理信息的系统以及处理物质、能量的系统的区别。

信息系统接收输入的信息，使用其内部所封装的逻辑计算得到输出的信息。不属于信息系统的其他系统，本书统称非信息系统。非人生命体（从大猩猩到病毒）以及各种机械（从老式的汽车到算盘）都归为非信息系统，不再细究其分类。

根据以上内容，系统初步分类如图2-3。

<img width="460" height="367" alt="image" src="https://github.com/user-attachments/assets/e89c6a5b-22aa-4903-adfa-f98ef1417135" />

图2-3 系统的初步分类

★虽然本书到第8章才开始讲解类图的建模，但第2到7章也会用类图来表达概念以及概念之间的关系，目的不是要建模类图，而是帮助理解。如果读者之前没有类图的基本知识，可先阅读本书第8章或其他UML书籍中的相关章节。其他UML书籍推荐《UML和模式应用》（Larman）或《UML精粹》（Fowler）。

根据所驻留的位置，信息系统又可以分为驻留人脑的信息系统（简称人脑系统）以及驻留计算机的信息系统（简称软件系统）。

此处的“计算机”是广义的，是支撑软件系统的基础设施的统称，而不单指某一台计算机的硬件。即使在单机时代，像“浑元太极学员管理系统”这样的软件也已经离计算机硬件有一定距离，更不用说现在的云计算和虚拟化了。

★选择用“软件系统”这个词和“人脑系统”对应，是一个折衷的选择。和“（驻留在）人脑（的）系统”对应的，最直接是“（驻留在）电脑（的）系统”。如果觉得“电脑”港台味浓或者不能用在学术场合，可以改为“（驻留在）计算机（的）系统”，但“计算机系统”一直以来被认为指计算机本身——类似于《深入理解计算机系统（CSAPP）》所讲解的内容。如果不使用“人脑系统”这个称呼，可能不会有这些问题，但目前先这样使用，特此说明。

图2-4表达了进一步的分类。

<img width="698" height="618" alt="image" src="https://github.com/user-attachments/assets/57c2c5a0-e26b-41cb-83c5-a2ed9eeee297" />

图2-4 系统根据驻留位置进一步分类

其实，像图2-4这样进一步泛化意义并不大，我们更在意的是系统的能力而不是驻留位置。同样能力的信息系统可以驻留在人脑中，也可以驻留在计算机中，人脑中的信息系统可以复刻到计算机，计算机中的信息系统也可以复刻到人脑。哪一个系统能力强，我们就用哪一个。

“人脑”和“计算机”可以看作两个容器类型，如图2-5。

<img width="593" height="229" alt="image" src="https://github.com/user-attachments/assets/b7fa1176-cc12-43d4-94bc-52710a6e70c5" />

图2-5 把人脑和计算机看作两个容器类型

把人脑看作容器，人担任的角色或职位看作驻留在人脑中的系统。例如，马宝国是一名.NET程序员，人称阿宝，同时也是一名浑元太极教练，人称马老师，这可以看作马宝国这个人脑中安装了“.NET程序员”和“浑元太极教练”两个系统。

同样，我们把计算机看作容器，上面可以驻留很多软件系统。例如，马宝国所使用的计算机安装了“Visual Studio 2022”和“浑元太极学员管理系统”。

我们把“时间”想象成运行在驻留在上帝中的信息系统，至于它是人脑系统还是软件系统，就要看我们把上帝看作是人还是计算机了。“时间”不停地向其他人脑系统或软件系统发送时间信号，这些系统收到时间信号后，可能会做一些事情。从物理学的角度，这个想象是有问题的，但对于本书的内容来说，这个想象够用了。

这里顺便谈一下面向对象初学者的一个常见错误（包括不久前刚批评的一个领域驱动设计创新“宏论”）。例如，研究一个烹调软件系统，这个系统里面有哪些类呢？有的人会认为系统里有一个“厨师”类，封装了烹调的逻辑。他这样想的理由是，如果没有这样的烹调软件系统，烹调的逻辑是放在厨师的人脑里。

根据上面的剖析，厨师对应的这个人只是一个容器。这个人之所以会烹调，不是因为他是人（我也是人，我就不会烹调），而是因为他的人脑里安装了“厨师”系统，这个“厨师”系统和以计算机为容器的“烹调软件”是对等的。

输入一个信息“宫保鸡丁”，人脑中的“厨师”系统为什么能想到一个烹调的流程，然后按照流程指挥他的手脚以及各种设备烹调？回答“因为系统里有一个厨师类”、“因为他是厨师”虽然很有DDD风味，却是没有意义的，有意义的回答是“因为系统（即厨师）知道菜品-制作步骤-食材之间的关系”。

同理，输入一个信息“宫保鸡丁”，计算机上的“烹调软件”系统为什么能输出一个烹调的流程，甚至能按照流程指挥电子烹调设备来烹调？回答“因为系统里有一个厨师类（烹调软件类）”也是没有意义的。有意义的回答是“因为系统（即厨师）知道菜品-制作步骤-食材之间的关系”。

实际上，人脑中的“厨师”系统中可以没有“厨师”类。厨师只要记得菜品-制作步骤-食材，忘了自己姓甚名谁并不妨碍烹调。同理，“烹调软件”也可以不需要厨师类，因为它不记住厨师的信息，不影响它输出烹调的流程。

注意：

（1）是“可以没有”。如果有需要，“厨师”或“烹调软件”当然可以记住厨师以及他和其他几个概念之间的关系。

（2）注意区分“厨师”和“（供）厨师（使用的）界面”。

第8章还会探讨这些问题。

2.1.3 系统和系统实例
--待续---
